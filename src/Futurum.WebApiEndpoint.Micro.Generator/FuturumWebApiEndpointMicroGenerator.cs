using System.Collections.Immutable;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Futurum.WebApiEndpoint.Micro.Generator;

[Generator]
public class FuturumWebApiEndpointMicroGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var webApiEndpointSyntaxNodes = context.SyntaxProvider
                                               .CreateSyntaxProvider(static (node, _) => node.IsKind(SyntaxKind.ClassDeclaration),
                                                                     (generatorSyntaxContext, ct) =>
                                                                         GetInstanceTypeSyntaxThatImplementInterface(generatorSyntaxContext, ct, "Futurum.WebApiEndpoint.Micro.IWebApiEndpoint"))
                                               .Where(node => node is not null);

        var fluentValidatorSyntaxNodes = context.SyntaxProvider
                                                .CreateSyntaxProvider(static (node, _) => node.IsKind(SyntaxKind.ClassDeclaration),
                                                                      (generatorSyntaxContext, ct) =>
                                                                          GetInstanceTypeSyntaxThatImplementGenericInterface(generatorSyntaxContext, ct, "FluentValidation", "IValidator`1"))
                                                .Where(node => node is not null);

        var compilationWithWebApiEndpoints = context.CompilationProvider
                                                    .Combine(webApiEndpointSyntaxNodes.Collect());

        var compilationWithFluentValidators = context.CompilationProvider
                                                     .Combine(fluentValidatorSyntaxNodes.Collect());

        context.RegisterSourceOutput(compilationWithWebApiEndpoints,
                                     static (spc, source) => Execute(source.Left, source.Right, spc));

        context.RegisterSourceOutput(compilationWithWebApiEndpoints,
                                     static (spc, source) => ExecuteWebApiEndpoint(source.Left, source.Right, spc));

        context.RegisterSourceOutput(compilationWithFluentValidators,
                                     static (spc, source) => ExecuteFluentValidator(source.Left, source.Right, spc));
    }

    private static void Execute(Compilation compilation, ImmutableArray<TypeDeclarationSyntax> webApiEndpointTypeDeclarations, SourceProductionContext context)
    {
        var firstWebApiEndpointTypeDeclarationSyntax = webApiEndpointTypeDeclarations.First();
        var rootNamespace = GetNamespaceRecursively(compilation.GetSemanticModel(firstWebApiEndpointTypeDeclarationSyntax.SyntaxTree).GetDeclaredSymbol(firstWebApiEndpointTypeDeclarationSyntax)
                                                               .ContainingNamespace);

        var projectName = rootNamespace.Replace(".", string.Empty);

        var source = new StringBuilder();

        source.AppendLine($@"// <auto-generated/>
using Futurum.Microsoft.Extensions.DependencyInjection;

namespace Futurum.WebApiEndpoint.Micro;

public static partial class WebApplicationStartupExtensions
{{
        public static IServiceCollection AddWebApiEndpointsFor{projectName}(this IServiceCollection serviceCollection)
        {{
");

        source.AppendLine("            serviceCollection.RegisterWebApiEndpoints();");
        source.AppendLine("            serviceCollection.RegisterFluentValidators();");

        source.AppendLine(@"
            return serviceCollection;
        }
}
");

        context.AddSource("Futurum.WebApiEndpoint.Micro.Generator.g.cs", SourceText.From(source.ToString(), Encoding.UTF8));
    }

    private static void ExecuteWebApiEndpoint(Compilation compilation, ImmutableArray<TypeDeclarationSyntax> webApiEndpointTypeDeclarations, SourceProductionContext context)
    {
        var source = new StringBuilder();

        source.AppendLine(@"// <auto-generated/>
namespace Futurum.WebApiEndpoint.Micro;

public static partial class WebApplicationStartupExtensions
{
        internal static IServiceCollection RegisterWebApiEndpoints(this IServiceCollection serviceCollection)
        {
");

        foreach (var webApiEndpointTypeDeclaration in webApiEndpointTypeDeclarations)
        {
            var semanticModel = compilation.GetSemanticModel(webApiEndpointTypeDeclaration.SyntaxTree);
            if (semanticModel.GetDeclaredSymbol(webApiEndpointTypeDeclaration) is not INamedTypeSymbol webApiEndpointTypeSymbol)
            {
                continue;
            }

            source.AppendLine($"            serviceCollection.AddSingleton(typeof(global::Futurum.WebApiEndpoint.Micro.IWebApiEndpoint), typeof(global::{webApiEndpointTypeSymbol}));");
        }

        source.AppendLine(@"

            return serviceCollection;
        }
}
");

        context.AddSource("Futurum.WebApiEndpoint.Micro.Generator.WebApiEndpoint.g.cs", SourceText.From(source.ToString(), Encoding.UTF8));
    }

    private static void ExecuteFluentValidator(Compilation compilation, ImmutableArray<TypeDeclarationSyntax> fluentValidatorTypeDeclarations, SourceProductionContext context)
    {
        var source = new StringBuilder();

        source.AppendLine(@"// <auto-generated/>
namespace Futurum.WebApiEndpoint.Micro;

public static partial class WebApplicationStartupExtensions
{
        internal static IServiceCollection RegisterFluentValidators(this IServiceCollection serviceCollection)
        {
");

        foreach (var fluentValidatorTypeDeclaration in fluentValidatorTypeDeclarations)
        {
            var semanticModel = compilation.GetSemanticModel(fluentValidatorTypeDeclaration.SyntaxTree);
            if (semanticModel.GetDeclaredSymbol(fluentValidatorTypeDeclaration) is not INamedTypeSymbol fluentValidatorTypeSymbol)
            {
                continue;
            }

            var interfaceNamedTypeSymbol = fluentValidatorTypeSymbol.AllInterfaces
                                                                    .First(t => t.ContainingNamespace.MetadataName == "FluentValidation" && t.MetadataName == "IValidator`1");

            source.AppendLine($"            serviceCollection.AddSingleton(typeof(global::{interfaceNamedTypeSymbol}), typeof(global::{fluentValidatorTypeSymbol}));");
        }

        source.AppendLine(@"

            return serviceCollection;
        }
}
");

        context.AddSource("Futurum.WebApiEndpoint.Micro.Generator.FluentValidator.g.cs", SourceText.From(source.ToString(), Encoding.UTF8));
    }

    private static TypeDeclarationSyntax GetInstanceTypeSyntaxThatImplementInterface(GeneratorSyntaxContext context, CancellationToken ct, string typeName)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;
        var semanticModel = context.SemanticModel;
        var classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration, ct);
        var interfaceTypeSymbol = semanticModel.Compilation.GetTypeByMetadataName(typeName);
        if (classSymbol is not null && interfaceTypeSymbol is not null)
        {
            var implementsInterface = classSymbol.AllInterfaces.Contains(interfaceTypeSymbol);


            if (implementsInterface)
            {
                return classDeclaration;
            }
        }

        return null;
    }

    private static TypeDeclarationSyntax GetInstanceTypeSyntaxThatImplementGenericInterface(GeneratorSyntaxContext context, CancellationToken ct, string namespaceName, string typeName)
    {
        if (context.Node is ClassDeclarationSyntax classDeclarationSyntax)
        {
            var semanticModel = context.SemanticModel;
            var classSymbol = semanticModel.GetDeclaredSymbol(classDeclarationSyntax, ct);

            if (classSymbol != null && classSymbol.AllInterfaces.Any(t => t.ContainingNamespace.MetadataName == namespaceName && t.MetadataName == typeName))
            {
                return classDeclarationSyntax;
            }

            return null;
        }

        return null;
    }

    private static string GetNamespaceRecursively(INamespaceSymbol symbol)
    {
        if (symbol.ContainingNamespace == null)
        {
            return symbol.Name;
        }

        return (GetNamespaceRecursively(symbol.ContainingNamespace) + "." + symbol.Name).Trim('.');
    }
}